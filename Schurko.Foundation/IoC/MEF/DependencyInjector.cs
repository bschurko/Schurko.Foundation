
using System;
using System.Collections.Generic;
using System.ComponentModel.Composition.Hosting;
using System.ComponentModel.Composition.Primitives;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;


#nullable enable
namespace Schurko.Foundation.IoC.MEF
{
    public static class DependencyInjector
    {
        private static readonly object ContainerLock = new object();
        private static volatile CompositionContainer _container;
        private static readonly string BaseConfigKey = typeof(DependencyInjector).FullName + ".{0}";
        private const string AdditionalCatalogPaths = "AdditionalCatalogPaths";
        private const string AssemblyAutoFilter = "MEFAssemblyAutoFilter";
        private const string ExcludeFilter = "ExcludeFilter";
        private const string GenerateResolveLog = "GenerateResolveLog";

        public static IEnumerable<string> ConfigHelp
        {
            get
            {
                yield return string.Format("Key {0} - {1}", "AdditionalCatalogPaths", "'|' seperated list of extra search directories, use ~ for relative. example ~/librarys/|~/thirdparty/");
                yield return string.Format("Key {0} - {1}", "MEFAssemblyAutoFilter", "Set this to FALSE if you want to disable the BUILD of MEFAssembylAutoFilter.ini, you must delete MEFAssembylAutoFilter.ini if you want to not use.");
                yield return string.Format("Key {0} - {1}", "ExcludeFilter", "'|' seperated list of exclusion filter, it is just a contains test. example demo.dll|test.dll|my.crap.dll");
                yield return string.Format("Key {0} - {1}", "GenerateResolveLog", "Set to 'true' if you want a verbose log detailing the MEF compatible libraries and the parts they contain. This is useful if you are not seeing an Export.");
                yield return "The MEFAssemblyAutoFilter.ini file is auto-magically generated from files that cause error during startup, these are typically dlls that are not MEF compatible. You can safely delete this file and it will be re-generated by the little elves that run your code.";
            }
        }

        private static CompositionContainer Container
        {
            get
            {
                if (_container != null)
                    return _container;
                lock (ContainerLock)
                {
                    if (_container == null)
                        _container = CreateCompositionContainer();
                }
                return _container;
            }
        }

        private static ComposablePartCatalog CreateCatalog()
        {
            string str1 = string.Format("{0}|{1}", !string.IsNullOrWhiteSpace(AppDomain.CurrentDomain.RelativeSearchPath) ? AppDomain.CurrentDomain.RelativeSearchPath : (object)AppDomain.CurrentDomain.BaseDirectory, GetConfigValue("AdditionalCatalogPaths", string.Empty));
            AggregateCatalog catalog = new AggregateCatalog();
            List<string> values = new List<string>();
            string str2 = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "config");
            if (!File.Exists(str2))
                Directory.CreateDirectory(str2);
            string path1 = Path.Combine(str2, "MEFAssemblyFail.log");
            string resolveLog = Path.Combine(str2, "MEFAssemblyResolve.log");
            string path2 = Path.Combine(str2, "MEFAssemblyFiltered.log");
            string path3 = Path.Combine(str2, "MEFAssemblyAutoFilter.ini");
            bool flag = GetConfigValue("MEFAssemblyAutoFilter", "true").Equals("true", StringComparison.InvariantCultureIgnoreCase);
            ClearLogFiles(path1, resolveLog, path2);
            string[] strArray1 = GetConfigValue("ExcludeFilter", string.Empty).Split(new char[1]
            {
        '|'
            }, StringSplitOptions.RemoveEmptyEntries);
            if (File.Exists(path3))
            {
                string[] strArray2 = File.ReadAllLines(path3);
                if (strArray2.Any())
                    strArray1 = strArray1.Concat((IEnumerable<string>)strArray2).ToArray();
            }
            Action<string, AssemblyCatalog> action = (_, __) => { };
            if (GetConfigValue("GenerateResolveLog", "false").Equals("true", StringComparison.InvariantCultureIgnoreCase))
                action = (file, assemblyCat) =>
                {
                    string str3 = string.Format("\r\n//----------\r\nNew AssemblyCatalog [{0}]", file);
                    string str4 = string.Empty;
                    foreach (ComposablePartDefinition part in (IEnumerable<ComposablePartDefinition>)assemblyCat.Parts)
                        str4 = string.Format("{0}\r\n-- [Class] {1}\r\n-- [Exports] :{2}\r\n", str4, part, part.ExportDefinitions.Aggregate(string.Empty, (s, def) => string.Format("{0}{1}{2}", s, s.Any() ? ", " : (object)string.Empty, def.ContractName)));
                    string str5 = string.Format("{0}\r\n{1}\r\n------------//\r\n", str3, str4);
                    try
                    {
                        File.AppendAllText(resolveLog, str5);
                    }
                    catch (Exception ex)
                    {
                        Log(str5);
                    }
                };
            foreach (string path4 in str1.Split(new char[1]
            {
        '|'
            }, StringSplitOptions.RemoveEmptyEntries).Select<string, string>(p => p.Replace("~/", AppDomain.CurrentDomain.BaseDirectory)))
            {
                if (string.IsNullOrWhiteSpace(path4))
                    throw new Exception("Unable to get path to 'bin' directory");
                foreach (string file1 in Directory.GetFiles(path4, "*.dll", SearchOption.AllDirectories))
                {
                    string file = file1;
                    try
                    {
                        if (strArray1.Any(f => file.ToLower().Contains(f.ToLower())))
                        {
                            string fileLocal = file;
                            string str6 = strArray1.Where(f => fileLocal.ToLower().Contains(f.ToLower())).Aggregate(string.Empty, (s, f) => string.Format("{0}{1}{2}", s, s.Any() ? ", " : (object)string.Empty, f));
                            string str7 = string.Format("File Exclusion Log\r\nFile excluded by filter [{0}], filters matched [{1}]\r\n", file, str6);
                            try
                            {
                                File.AppendAllText(path2, str7);
                            }
                            catch (Exception ex)
                            {
                                Log(str7);
                            }
                        }
                        else
                        {
                            AssemblyCatalog assemblyCatalog = new AssemblyCatalog(file);
                            if (assemblyCatalog.Parts.Any())
                            {
                                catalog.Catalogs.Add(assemblyCatalog);
                                action(file, assemblyCatalog);
                            }
                        }
                    }
                    catch (Exception ex1)
                    {
                        values.Add(string.Format("\r\n{0}\r\n{1}\r\n", file, ex1));
                        if (flag)
                        {
                            try
                            {
                                File.AppendAllText(path3, file);
                            }
                            catch (Exception ex2)
                            {
                                Log(ex1.ToString());
                            }
                        }
                    }
                }
            }
            if (values.Count <= 0)
                return catalog;
            try
            {
                File.WriteAllLines(path1, values.ToArray());
            }
            catch (Exception ex)
            {
                Log(string.Format("Errors: {0}", string.Join(", ", (IEnumerable<string>)values)));
            }
            return catalog;
        }

        private static string GetConfigValue(string key, string defaultValue = null) => ConfigurationManager.AppSettings[string.Format(BaseConfigKey, key)] ?? defaultValue;

        private static void ClearLogFiles(params string[] fileNames)
        {
            foreach (string fileName in fileNames)
            {
                try
                {
                    File.Delete(fileName);
                }
                catch (Exception ex)
                {
                    Log("Error trying to clear log file {0}", ex);
                }
            }
        }

        private static CompositionContainer CreateCompositionContainer() => new CompositionContainer(CreateCatalog(), true, Array.Empty<ExportProvider>());

        public static TServiceType Resolve<TServiceType>() where TServiceType : class => AllWithMetaData<TServiceType>().Where(t => !t.Metadata.Any(m => string.Compare(m.Key, "default", StringComparison.InvariantCultureIgnoreCase) + string.Compare(m.Value.ToString(), typeof(TServiceType).Name, StringComparison.InvariantCultureIgnoreCase) == 0)).Select(e => e.Value).FirstOrDefault() ?? (TServiceType)Resolve(typeof(TServiceType));

        public static TServiceType Resolve<TServiceType, TDefault>() where TDefault : TServiceType, new() => Resolve((Func<TServiceType>)(() => new TDefault()));

        public static TServiceType Resolve<TServiceType>(Func<TServiceType> defaultImplementationCreator) => ResolveInternal(defaultImplementationCreator);

        public static object Resolve(Type serviceType) => Resolve(serviceType, null);

        public static object Resolve(Type serviceType, Func<object> defaultImplementation) => ResolveInternal(serviceType, defaultImplementation);

        public static IEnumerable<TServiceType> ResolveAll<TServiceType>(
          params Func<TServiceType>[] defaultIfNotResolved)
        {
            return ResolveAllInternal(defaultIfNotResolved);
        }

        public static IEnumerable<object> ResolveAll(
          Type serviceType,
          params Func<object>[] defaultIfNotResolved)
        {
            return ResolveAllInternal(serviceType, defaultIfNotResolved);
        }

        public static IEnumerable<Lazy<TServiceType, IDictionary<string, object>>> AllWithMetaData<TServiceType>() => Container.GetExports<TServiceType, IDictionary<string, object>>();

        private static IEnumerable<TServiceType> ResolveAllInternal<TServiceType>(
          params Func<TServiceType>[] defaultIfNotResolvedArgs)
        {
            return ResolveAllInternal(typeof(TServiceType), defaultIfNotResolvedArgs);
        }

        private static IEnumerable<TCastType> ResolveAllInternal<TCastType>(
          Type serviceType,
          params Func<TCastType>[] defaultIfNotResolvedArgs)
        {
            TCastType[] array = Container.GetExports(serviceType, null, string.Empty).Select(i => (TCastType)i.Value).ToArray();
            return !array.Any() || defaultIfNotResolvedArgs.Length == 0 ? (IEnumerable<TCastType>)array : defaultIfNotResolvedArgs.Select(a => a());
        }

        private static TServiceType ResolveInternal<TServiceType>(
          Func<TServiceType> defaultIfNotResolved)
        {
            return ResolveInternal(typeof(TServiceType), defaultIfNotResolved);
        }

        private static TServiceType ResolveInternal<TServiceType>(
          Type serviceType,
          Func<TServiceType> defaultIfNotResolved)
        {
            Lazy<object, object>[] array = Container.GetExports(serviceType, null, string.Empty).ToArray();
            Lazy<object, object> lazy = array.Count() <= 1 ? array.SingleOrDefault() : throw new ResolveEntityException(typeof(TServiceType).Name, Container.Catalog, "More than one viable instance of this type is available but insufficient criteria is provded to filter. Try using AllWithMetaData.Filter.Resolver. Types found ->" + array.Aggregate(string.Empty, (s, o) => string.Format("{0},{1}", s, o.Value.GetType().Name)), null);
            if (lazy == null)
            {
                Log("Unable to resolve requested type [{0}], ensure you have used 'Export attribute' to mark the class for MEF", serviceType.FullName);
                string contractName = typeof(TServiceType).FullName;
                if (Container.Catalog.Parts.Any((Expression<Func<ComposablePartDefinition, bool>>)(p => p.Exports(contractName))))
                {
                    Log("An implementation of the requested type {0} exists but was not returned by the call Container.GetExports({0}, null, string.Empty).SingleOrDefault(); Typically this occurs if a sub dependancy fails to resolve e.g. an [Imports] on a property.", contractName);
                    if (defaultIfNotResolved == null)
                        throw new ResolveEntityException(typeof(TServiceType).FullName, Container.Catalog, string.Format("An implementation of the requested type {0} exists but was not returned by the call Container.GetExports({0}, null, string.Empty).SingleOrDefault(); Typically this occurs if a sub dependancy fails to resolve e.g. an [Imports] on a property.", contractName), null);
                }
            }
            return lazy == null ? defaultIfNotResolved() : (TServiceType)lazy.Value;
        }

        private static void Log(string message, params object[] args)
        {
            if (args.Length != 0 && message.Contains("{0}"))
                message = string.Format(message, args);
            Trace.WriteLine(message);
        }
    }
}
