// Decompiled with JetBrains decompiler
// Type: PNI.Ioc.MEF.DependencyInjector
// Assembly: Schurko.Foundation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1385A3BB-C317-4A00-BA85-BA0E3328BBAC
// Assembly location: E:\C Drive\nuget\Schurko.Foundation\src\lib\net7.0\Schurko.Foundation.dll

using System;
using System.Collections.Generic;
using System.ComponentModel.Composition.Hosting;
using System.ComponentModel.Composition.Primitives;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;


#nullable enable
namespace PNI.Ioc.MEF
{
  public static class DependencyInjector
  {
    private static readonly object ContainerLock = new object();
    private static volatile CompositionContainer _container;
    private static readonly string BaseConfigKey = typeof (DependencyInjector).FullName + ".{0}";
    private const string AdditionalCatalogPaths = "AdditionalCatalogPaths";
    private const string AssemblyAutoFilter = "MEFAssemblyAutoFilter";
    private const string ExcludeFilter = "ExcludeFilter";
    private const string GenerateResolveLog = "GenerateResolveLog";

    public static IEnumerable<string> ConfigHelp
    {
      get
      {
        yield return string.Format("Key {0} - {1}", (object) "AdditionalCatalogPaths", (object) "'|' seperated list of extra search directories, use ~ for relative. example ~/librarys/|~/thirdparty/");
        yield return string.Format("Key {0} - {1}", (object) "MEFAssemblyAutoFilter", (object) "Set this to FALSE if you want to disable the BUILD of MEFAssembylAutoFilter.ini, you must delete MEFAssembylAutoFilter.ini if you want to not use.");
        yield return string.Format("Key {0} - {1}", (object) "ExcludeFilter", (object) "'|' seperated list of exclusion filter, it is just a contains test. example demo.dll|test.dll|my.crap.dll");
        yield return string.Format("Key {0} - {1}", (object) "GenerateResolveLog", (object) "Set to 'true' if you want a verbose log detailing the MEF compatible libraries and the parts they contain. This is useful if you are not seeing an Export.");
        yield return "The MEFAssemblyAutoFilter.ini file is auto-magically generated from files that cause error during startup, these are typically dlls that are not MEF compatible. You can safely delete this file and it will be re-generated by the little elves that run your code.";
      }
    }

    private static CompositionContainer Container
    {
      get
      {
        if (DependencyInjector._container != null)
          return DependencyInjector._container;
        lock (DependencyInjector.ContainerLock)
        {
          if (DependencyInjector._container == null)
            DependencyInjector._container = DependencyInjector.CreateCompositionContainer();
        }
        return DependencyInjector._container;
      }
    }

    private static ComposablePartCatalog CreateCatalog()
    {
      string str1 = string.Format("{0}|{1}", !string.IsNullOrWhiteSpace(AppDomain.CurrentDomain.RelativeSearchPath) ? (object) AppDomain.CurrentDomain.RelativeSearchPath : (object) AppDomain.CurrentDomain.BaseDirectory, (object) DependencyInjector.GetConfigValue("AdditionalCatalogPaths", string.Empty));
      AggregateCatalog catalog = new AggregateCatalog();
      List<string> values = new List<string>();
      string str2 = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "config");
      if (!File.Exists(str2))
        Directory.CreateDirectory(str2);
      string path1 = Path.Combine(str2, "MEFAssemblyFail.log");
      string resolveLog = Path.Combine(str2, "MEFAssemblyResolve.log");
      string path2 = Path.Combine(str2, "MEFAssemblyFiltered.log");
      string path3 = Path.Combine(str2, "MEFAssemblyAutoFilter.ini");
      bool flag = DependencyInjector.GetConfigValue("MEFAssemblyAutoFilter", "true").Equals("true", StringComparison.InvariantCultureIgnoreCase);
      DependencyInjector.ClearLogFiles(path1, resolveLog, path2);
      string[] strArray1 = DependencyInjector.GetConfigValue("ExcludeFilter", string.Empty).Split(new char[1]
      {
        '|'
      }, StringSplitOptions.RemoveEmptyEntries);
      if (File.Exists(path3))
      {
        string[] strArray2 = File.ReadAllLines(path3);
        if (((IEnumerable<string>) strArray2).Any<string>())
          strArray1 = ((IEnumerable<string>) strArray1).Concat<string>((IEnumerable<string>) strArray2).ToArray<string>();
      }
      Action<string, AssemblyCatalog> action = (Action<string, AssemblyCatalog>) ((_, __) => { });
      if (DependencyInjector.GetConfigValue("GenerateResolveLog", "false").Equals("true", StringComparison.InvariantCultureIgnoreCase))
        action = (Action<string, AssemblyCatalog>) ((file, assemblyCat) =>
        {
          string str3 = string.Format("\r\n//----------\r\nNew AssemblyCatalog [{0}]", (object) file);
          string str4 = string.Empty;
          foreach (ComposablePartDefinition part in (IEnumerable<ComposablePartDefinition>) assemblyCat.Parts)
            str4 = string.Format("{0}\r\n-- [Class] {1}\r\n-- [Exports] :{2}\r\n", (object) str4, (object) part, (object) part.ExportDefinitions.Aggregate<ExportDefinition, string>(string.Empty, (Func<string, ExportDefinition, string>) ((s, def) => string.Format("{0}{1}{2}", (object) s, s.Any<char>() ? (object) ", " : (object) string.Empty, (object) def.ContractName))));
          string str5 = string.Format("{0}\r\n{1}\r\n------------//\r\n", (object) str3, (object) str4);
          try
          {
            File.AppendAllText(resolveLog, str5);
          }
          catch (Exception ex)
          {
            DependencyInjector.Log(str5);
          }
        });
      foreach (string path4 in ((IEnumerable<string>) str1.Split(new char[1]
      {
        '|'
      }, StringSplitOptions.RemoveEmptyEntries)).Select<string, string>((Func<string, string>) (p => p.Replace("~/", AppDomain.CurrentDomain.BaseDirectory))))
      {
        if (string.IsNullOrWhiteSpace(path4))
          throw new Exception("Unable to get path to 'bin' directory");
        foreach (string file1 in Directory.GetFiles(path4, "*.dll", SearchOption.AllDirectories))
        {
          string file = file1;
          try
          {
            if (((IEnumerable<string>) strArray1).Any<string>((Func<string, bool>) (f => file.ToLower().Contains(f.ToLower()))))
            {
              string fileLocal = file;
              string str6 = ((IEnumerable<string>) strArray1).Where<string>((Func<string, bool>) (f => fileLocal.ToLower().Contains(f.ToLower()))).Aggregate<string, string>(string.Empty, (Func<string, string, string>) ((s, f) => string.Format("{0}{1}{2}", (object) s, s.Any<char>() ? (object) ", " : (object) string.Empty, (object) f)));
              string str7 = string.Format("File Exclusion Log\r\nFile excluded by filter [{0}], filters matched [{1}]\r\n", (object) file, (object) str6);
              try
              {
                File.AppendAllText(path2, str7);
              }
              catch (Exception ex)
              {
                DependencyInjector.Log(str7);
              }
            }
            else
            {
              AssemblyCatalog assemblyCatalog = new AssemblyCatalog(file);
              if (assemblyCatalog.Parts.Any<ComposablePartDefinition>())
              {
                catalog.Catalogs.Add((ComposablePartCatalog) assemblyCatalog);
                action(file, assemblyCatalog);
              }
            }
          }
          catch (Exception ex1)
          {
            values.Add(string.Format("\r\n{0}\r\n{1}\r\n", (object) file, (object) ex1));
            if (flag)
            {
              try
              {
                File.AppendAllText(path3, file);
              }
              catch (Exception ex2)
              {
                DependencyInjector.Log(ex1.ToString());
              }
            }
          }
        }
      }
      if (values.Count <= 0)
        return (ComposablePartCatalog) catalog;
      try
      {
        File.WriteAllLines(path1, values.ToArray());
      }
      catch (Exception ex)
      {
        DependencyInjector.Log(string.Format("Errors: {0}", (object) string.Join(", ", (IEnumerable<string>) values)));
      }
      return (ComposablePartCatalog) catalog;
    }

    private static string GetConfigValue(string key, string defaultValue = null) => ConfigurationManager.AppSettings[string.Format(DependencyInjector.BaseConfigKey, (object) key)] ?? defaultValue;

    private static void ClearLogFiles(params string[] fileNames)
    {
      foreach (string fileName in fileNames)
      {
        try
        {
          File.Delete(fileName);
        }
        catch (Exception ex)
        {
          DependencyInjector.Log("Error trying to clear log file {0}", (object) ex);
        }
      }
    }

    private static CompositionContainer CreateCompositionContainer() => new CompositionContainer(DependencyInjector.CreateCatalog(), true, Array.Empty<ExportProvider>());

    public static TServiceType Resolve<TServiceType>() where TServiceType : class => DependencyInjector.AllWithMetaData<TServiceType>().Where<Lazy<TServiceType, IDictionary<string, object>>>((Func<Lazy<TServiceType, IDictionary<string, object>>, bool>) (t => !t.Metadata.Any<KeyValuePair<string, object>>((Func<KeyValuePair<string, object>, bool>) (m => string.Compare(m.Key, "default", StringComparison.InvariantCultureIgnoreCase) + string.Compare(m.Value.ToString(), typeof (TServiceType).Name, StringComparison.InvariantCultureIgnoreCase) == 0)))).Select<Lazy<TServiceType, IDictionary<string, object>>, TServiceType>((Func<Lazy<TServiceType, IDictionary<string, object>>, TServiceType>) (e => e.Value)).FirstOrDefault<TServiceType>() ?? (TServiceType) DependencyInjector.Resolve(typeof (TServiceType));

    public static TServiceType Resolve<TServiceType, TDefault>() where TDefault : TServiceType, new() => DependencyInjector.Resolve<TServiceType>((Func<TServiceType>) (() => (TServiceType) new TDefault()));

    public static TServiceType Resolve<TServiceType>(Func<TServiceType> defaultImplementationCreator) => DependencyInjector.ResolveInternal<TServiceType>(defaultImplementationCreator);

    public static object Resolve(Type serviceType) => DependencyInjector.Resolve(serviceType, (Func<object>) null);

    public static object Resolve(Type serviceType, Func<object> defaultImplementation) => DependencyInjector.ResolveInternal<object>(serviceType, defaultImplementation);

    public static IEnumerable<TServiceType> ResolveAll<TServiceType>(
      params Func<TServiceType>[] defaultIfNotResolved)
    {
      return DependencyInjector.ResolveAllInternal<TServiceType>(defaultIfNotResolved);
    }

    public static IEnumerable<object> ResolveAll(
      Type serviceType,
      params Func<object>[] defaultIfNotResolved)
    {
      return DependencyInjector.ResolveAllInternal<object>(serviceType, defaultIfNotResolved);
    }

    public static IEnumerable<Lazy<TServiceType, IDictionary<string, object>>> AllWithMetaData<TServiceType>() => DependencyInjector.Container.GetExports<TServiceType, IDictionary<string, object>>();

    private static IEnumerable<TServiceType> ResolveAllInternal<TServiceType>(
      params Func<TServiceType>[] defaultIfNotResolvedArgs)
    {
      return DependencyInjector.ResolveAllInternal<TServiceType>(typeof (TServiceType), defaultIfNotResolvedArgs);
    }

    private static IEnumerable<TCastType> ResolveAllInternal<TCastType>(
      Type serviceType,
      params Func<TCastType>[] defaultIfNotResolvedArgs)
    {
      TCastType[] array = DependencyInjector.Container.GetExports(serviceType, (Type) null, string.Empty).Select<Lazy<object, object>, TCastType>((Func<Lazy<object, object>, TCastType>) (i => (TCastType) i.Value)).ToArray<TCastType>();
      return !((IEnumerable<TCastType>) array).Any<TCastType>() || defaultIfNotResolvedArgs.Length == 0 ? (IEnumerable<TCastType>) array : ((IEnumerable<Func<TCastType>>) defaultIfNotResolvedArgs).Select<Func<TCastType>, TCastType>((Func<Func<TCastType>, TCastType>) (a => a()));
    }

    private static TServiceType ResolveInternal<TServiceType>(
      Func<TServiceType> defaultIfNotResolved)
    {
      return DependencyInjector.ResolveInternal<TServiceType>(typeof (TServiceType), defaultIfNotResolved);
    }

    private static TServiceType ResolveInternal<TServiceType>(
      Type serviceType,
      Func<TServiceType> defaultIfNotResolved)
    {
      Lazy<object, object>[] array = DependencyInjector.Container.GetExports(serviceType, (Type) null, string.Empty).ToArray<Lazy<object, object>>();
      Lazy<object, object> lazy = ((IEnumerable<Lazy<object, object>>) array).Count<Lazy<object, object>>() <= 1 ? ((IEnumerable<Lazy<object, object>>) array).SingleOrDefault<Lazy<object, object>>() : throw new ResolveEntityException(typeof (TServiceType).Name, DependencyInjector.Container.Catalog, "More than one viable instance of this type is available but insufficient criteria is provded to filter. Try using AllWithMetaData.Filter.Resolver. Types found ->" + ((IEnumerable<Lazy<object, object>>) array).Aggregate<Lazy<object, object>, string>(string.Empty, (Func<string, Lazy<object, object>, string>) ((s, o) => string.Format("{0},{1}", (object) s, (object) o.Value.GetType().Name))), (Exception) null);
      if (lazy == null)
      {
        DependencyInjector.Log("Unable to resolve requested type [{0}], ensure you have used 'Export attribute' to mark the class for MEF", (object) serviceType.FullName);
        string contractName = typeof (TServiceType).FullName;
        if (DependencyInjector.Container.Catalog.Parts.Any<ComposablePartDefinition>((Expression<Func<ComposablePartDefinition, bool>>) (p => p.Exports(contractName))))
        {
          DependencyInjector.Log("An implementation of the requested type {0} exists but was not returned by the call Container.GetExports({0}, null, string.Empty).SingleOrDefault(); Typically this occurs if a sub dependancy fails to resolve e.g. an [Imports] on a property.", (object) contractName);
          if (defaultIfNotResolved == null)
            throw new ResolveEntityException(typeof (TServiceType).FullName, DependencyInjector.Container.Catalog, string.Format("An implementation of the requested type {0} exists but was not returned by the call Container.GetExports({0}, null, string.Empty).SingleOrDefault(); Typically this occurs if a sub dependancy fails to resolve e.g. an [Imports] on a property.", (object) contractName), (Exception) null);
        }
      }
      return lazy == null ? defaultIfNotResolved() : (TServiceType) lazy.Value;
    }

    private static void Log(string message, params object[] args)
    {
      if (args.Length != 0 && message.Contains("{0}"))
        message = string.Format(message, args);
      Trace.WriteLine(message);
    }
  }
}
